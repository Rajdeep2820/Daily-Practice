// Learning Objective: This tutorial teaches how to procedurally generate abstract art
// using the concept of "random walks" and basic geometric shapes (lines and circles)
// in C++. We will explore how random movements can create organic and unpredictable
// visual patterns.

#include <iostream> // For console output (like printing error messages or status)
#include <vector>   // To store our shapes and drawing instructions
#include <random>   // For generating random numbers, crucial for random walks
#include <cmath>    // For mathematical functions like sin, cos (though not strictly needed here, good practice)
#include <fstream>  // To write the output to a file (e.g., an SVG file)

// --- Configuration ---
const int IMAGE_WIDTH = 800;  // The width of our generated artwork in pixels.
const int IMAGE_HEIGHT = 600; // The height of our generated artwork in pixels.
const int NUM_WALKS = 50;     // The number of independent random walks to perform.
const int STEPS_PER_WALK = 200; // How many steps each random walk will take.
const int MIN_LINE_THICKNESS = 1; // Minimum thickness for lines.
const int MAX_LINE_THICKNESS = 5; // Maximum thickness for lines.
const int MIN_RADIUS = 5;     // Minimum radius for circles.
const int MAX_RADIUS = 20;    // Maximum radius for circles.

// --- Helper Functions ---

// Generates a random integer within a specified range [min, max]
int randomInt(int min, int max) {
    // This uses a Mersenne Twister engine, a high-quality random number generator.
    // static ensures that the engine and distribution are created only once,
    // making it efficient and ensuring better randomness across calls.
    static std::random_device rd; // Seed from a hardware entropy source if available.
    static std::mt19937 gen(rd()); // Mersenne Twister engine initialized with the seed.
    std::uniform_int_distribution<> distrib(min, max); // Distribution that produces integers uniformly.
    return distrib(gen); // Generate and return a random number.
}

// Generates a random floating-point number within a specified range [min, max]
float randomFloat(float min, float max) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_real_distribution<> distrib(min, max); // Distribution for floating-point numbers.
    return distrib(gen);
}

// --- Data Structures for Drawing ---

// Represents a single point in 2D space.
struct Point {
    int x, y;
};

// Represents a line segment with a start and end point, and thickness.
struct Line {
    Point start;
    Point end;
    int thickness;
    // Color information could be added here later (e.g., RGB struct).
};

// Represents a circle with a center point, radius.
struct Circle {
    Point center;
    int radius;
    // Color information could be added here later.
};

// We'll use a vector to store all the drawing elements we generate.
// This allows us to easily add and iterate through our shapes.
// For simplicity, we'll decide whether to draw a line or a circle based on a random chance.
enum ShapeType {
    LINE,
    CIRCLE
};

struct ArtElement {
    ShapeType type;
    Line line;      // Valid if type == LINE
    Circle circle;  // Valid if type == CIRCLE
    // We could add color here too!
};

// --- Random Walk Generation ---

// This function performs a single random walk and generates a series of points.
// The points are then used to create drawing elements (lines or circles).
std::vector<ArtElement> generateRandomWalk(Point start_point) {
    std::vector<ArtElement> elements; // To store the shapes generated by this walk.
    Point current_pos = start_point; // The current position of our "walker".

    // For each step in the walk:
    for (int i = 0; i < STEPS_PER_WALK; ++i) {
        // Determine the next random movement.
        // dx and dy represent the change in x and y coordinates.
        int dx = randomInt(-5, 5); // Move horizontally by -5 to +5 pixels.
        int dy = randomInt(-5, 5); // Move vertically by -5 to +5 pixels.

        Point next_pos = {current_pos.x + dx, current_pos.y + dy}; // Calculate the next position.

        // --- Boundary Checking ---
        // Ensure the walker stays within the image boundaries.
        // This prevents drawing outside our canvas.
        next_pos.x = std::max(0, std::min(IMAGE_WIDTH - 1, next_pos.x));
        next_pos.y = std::max(0, std::min(IMAGE_HEIGHT - 1, next_pos.y));

        // --- Decide what to draw: Line or Circle? ---
        // We'll randomly choose between drawing a line or a circle at this step.
        if (randomInt(0, 1) == 0) { // 50% chance of drawing a line
            Line segment;
            segment.start = current_pos; // The line starts from the current position.
            segment.end = next_pos;      // The line ends at the newly calculated position.
            segment.thickness = randomInt(MIN_LINE_THICKNESS, MAX_LINE_THICKNESS); // Random thickness.
            elements.push_back({ShapeType::LINE, segment, {}}); // Add the line to our list of elements.
        } else { // 50% chance of drawing a circle
            Circle dot;
            dot.center = next_pos; // The circle is centered at the new position.
            dot.radius = randomInt(MIN_RADIUS, MAX_RADIUS); // Random radius.
            elements.push_back({ShapeType::CIRCLE, {}, dot}); // Add the circle to our list of elements.
        }

        current_pos = next_pos; // Update the current position for the next step.
    }
    return elements; // Return all the shapes generated by this single walk.
}

// --- SVG Output ---
// SVG (Scalable Vector Graphics) is a great format for web-based and scalable vector art.
// It's also human-readable, making it easy to understand how the art is represented.

void saveAsSVG(const std::vector<ArtElement>& all_elements, const std::string& filename) {
    std::ofstream svg_file(filename); // Open the file for writing.

    if (!svg_file.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " for writing." << std::endl;
        return;
    }

    // --- SVG Header ---
    // This defines the SVG canvas size and other properties.
    svg_file << "<svg width=\"" << IMAGE_WIDTH << "\" height=\"" << IMAGE_HEIGHT << "\" xmlns=\"http://www.w3.org/2000/svg\">\n";

    // --- Background ---
    // A simple white background. You could add gradients or other fills here.
    svg_file << "  <rect width=\"100%\" height=\"100%\" fill=\"white\"/>\n";

    // --- Drawing Elements ---
    // Iterate through all the generated art elements and write them to the SVG file.
    for (const auto& element : all_elements) {
        if (element.type == ShapeType::LINE) {
            const Line& line = element.line;
            // The <line> element in SVG requires 'x1', 'y1', 'x2', 'y2', and 'stroke-width'.
            // For simplicity, we'll use a black stroke color.
            svg_file << "  <line x1=\"" << line.start.x << "\" y1=\"" << line.start.y
                     << "\" x2=\"" << line.end.x << "\" y2=\"" << line.end.y
                     << "\" stroke=\"black\" stroke-width=\"" << line.thickness << "\" />\n";
        } else if (element.type == ShapeType::CIRCLE) {
            const Circle& circle = element.circle;
            // The <circle> element in SVG requires 'cx', 'cy' (center coordinates), 'r' (radius), and 'fill'.
            // For simplicity, we'll use a black fill color.
            svg_file << "  <circle cx=\"" << circle.center.x << "\" cy=\"" << circle.center.y
                     << "\" r=\"" << circle.radius << "\" fill=\"black\" />\n";
        }
    }

    // --- SVG Footer ---
    svg_file << "</svg>\n";
    svg_file.close(); // Close the file.
    std::cout << "Abstract art saved to " << filename << std::endl;
}

// --- Main Execution ---

int main() {
    std::vector<ArtElement> all_art_elements; // A collection to hold all elements from all walks.

    // Generate multiple random walks.
    // Each walk starts from a random point within the image.
    for (int i = 0; i < NUM_WALKS; ++i) {
        Point start_point = {randomInt(0, IMAGE_WIDTH), randomInt(0, IMAGE_HEIGHT)}; // Pick a random starting point.
        std::vector<ArtElement> walk_elements = generateRandomWalk(start_point); // Generate elements for this walk.
        // Add the elements from this walk to our main collection.
        all_art_elements.insert(all_art_elements.end(), walk_elements.begin(), walk_elements.end());
    }

    // Save the generated art to an SVG file.
    saveAsSVG(all_art_elements, "abstract_art.svg");

    return 0; // Indicate successful execution.
}

// Example Usage:
// Compile this code using a C++ compiler (like g++):
// g++ -std=c++11 -o abstract_art abstract_art_tutorial.cpp
//
// Then run the executable:
// ./abstract_art
//
// This will create a file named "abstract_art.svg" in the same directory.
// You can open this SVG file in a web browser or an SVG editor to view your abstract art.
//
// Experiment by changing the constants at the top of the file:
// - IMAGE_WIDTH, IMAGE_HEIGHT: Change the canvas size.
// - NUM_WALKS: More walks will create a denser image.
// - STEPS_PER_WALK: Longer walks create more connected or sprawling shapes.
// - MIN/MAX values for thickness and radius: Affect the visual style.
//
// You could also extend this by:
// - Adding color generation (e.g., random RGB values).
// - Implementing different types of shapes (rectangles, polygons).
// - Creating more complex movement patterns for the random walks.
// - Using different probability distributions for movements or shape choices.